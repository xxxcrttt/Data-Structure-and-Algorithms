# 概述

## 算法
Algorithms: 一系列程序指令，用于解决特定的运算和逻辑问题.   
衡量算法的好坏: 旨在计算在输入数据量N的情况下，算法的 时间复杂度 + 空间复杂度：  
体现算法运行使用的时间和空间随’数据大小N‘而增大的速度   
运用领域: 1. 运算 2. 查找 3. 排序 4. 最优决策    

数据结构: 数据的组织，管理和存储格式，其目的是为了高效的访问和修改数据.   
1. 线性结构 -- 包括数组，链表，衍生的栈，队列，Hash
2. 树 -- 二叉树，二叉堆
3. 图  

### 时间复杂度
指输入数据大小为 N 时，算法运行所需要花费的时间: 
* 统计的是算法的**计算操作数量** 而非运行的绝对时间，它们程正相关关系
* 体现的是计算操作随数据大小 N 变化时的情况
* 根据输入数据的特点，具有 最差 -- O(); 最好 -- Ω(); 平均 -- Θ 

**渐进时间复杂度 asymptotic time complexity**     
定义:   
若存在函数 f(n), 使得当 n 趋近于无穷大时, T(n) / f(n) 的极限值为不等于 0 的常数, 则称 f(n) 是 T(n) 的同数量级函数       
原则:   
1. 若运行时间是常数量级, 则用常数 1 表示;    
2. 只保留时间函数中的最高阶项 - 若存在最高阶项，则省去前面的系数
```
O(1) < O(logN) < O(N) < O(NlogN) < O(N^2) < O(2^N) < O(N!)
```
#### Example

##### O(1) -- 常数
运行次数与 N 的大小呈常数关系，即不随输入数据大小 N 的变化而变化 
```python
def algorithm(N):
    a = 1
    b = 2
    x = a * b + N
    return 1
```
```Java 
int algorithm(int N) {
    int count = 0;
    int a = 1000;
    // 无论 a 的取值，都与输入大小 N 无关 -- 因此是常数
    for (int i = 0; i < a; i++) {
        count ++;
    }
    return count;
}
```
##### O(N) -- 线性
循环运行次数与 N 呈线性关系
```Python
def algorithm(N):
    count = 0
    for i in range(N):
        count += 1
    return count
```
```Java
int algorithm(int N) {
    int count = 0;
    int a = 10000;
    for (int i = 0; i < N; i++) {
        // 虽然是双层循环，但第二层与 N 无关
        // 整体仍然和 N 呈线性关系
        for (int j = 0; j < a; j++) {
            count++；
        }
    }
    return count;
}
```
##### O(N^2) -- 平方
两层循环相互独立，都与 N 呈线性关系，因此总体与 N 呈平方关系
```Python
def algorithm(N):
    count = 0
    for i in range(N):
        for j in range(N):
            count += 1
    return count 
```
```Java
int algorithm(int N) {
    int count = 0;
    // 两个循环都与 N 相关
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            count++；
        }
    }
    return count;
}
```
##### O(2^N) -- 指数
常出现于递归，类似细胞分裂
```Python
def algorithm(N):
    if N <=0:
        return 1
    count_1 = algorithm(N - 1)
    count_2 = algorithm(N - 1)
    return count_1 + count_2
```
```Java 
int algorithm(int N) {
    if (N <= 0) return 1;
    int count_1 = algorithm(N-1);
    int count_2 = algorithm(N-1);
    return count_1 + count_2;
}
```
##### O(N!) -- 阶乘
全排列: 给定 N 个互不重复的元素，求其所有可能的排列方案: 
```N × (N−1) × (N−2) × ⋯ × 2 × 1 = N!```  
常用递归实现, 原理: 第一层分裂 N 个，第二层分类 N-1 个... 直到第 N 层终止并回溯
```Python
def algorithm(N):
    if N <=0:
        return 1
    count = 0
    # _ 是循环标志，在之后不会用到，等同于 i, j
    for _ in range(N):
        count += algorithm(N - 1)
    return count
```
```Java
int algorithm(int N) {
    if (N <= 0) return 1;
    int count = 0;
    for (int i = 0; i < N; i++) {
        count += algorithm(N - 1);
    }
    return count;
}
```
##### O(log N) -- 对数
"每轮排除一半的情况" 常出现在**二分法** **分治**等算法中，体现"一分为二(多)"的思想   
设循环次数为 m, 则输入 N 与 2^m 呈线性关系，两边同时取 log2 对数 ==> 循环次数 m 与 (log2 N) 呈线性关系
```Python
def algorithm(N):
    count = 0
    i = N
    while i > 1:
        i = i / 2
        count += 1
    return count
```






